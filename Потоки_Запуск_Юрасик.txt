private void StartThreads()
 {
		//Опрос устройств
		try
		{
			if (HARDWARE_GROUP_MODBUS.Channels != null)
			{
				//Приходимся по списку каналов
				for (int i = 0; i < HARDWARE_GROUP_MODBUS.Channels.Count; i++)
				{
					CHANNEL thread_channel = HARDWARE_GROUP_MODBUS.Channels[i];
					//Делаем признак, что каналы можно запускать
					thread_channel.ChannelThreadEnabled = true;
					//А вот если пользователь выставил, что этот канал не надо запускать, то его пропускаем и не трогаем
					if (thread_channel.ChannelEnabled == true)
					{
						int port = 0;
						if (thread_channel.GatewayTypeProtocol == 0)
						{
							//Если шлюз не указан т.е. выключен, то генерируем порт 
							port = GENERATE_TCP_SERVER_PORT.PORT_NEW();
						}
						else
						{
							bool checked_port = GENERATE_TCP_SERVER_PORT.CheckAvailableServerPort(Convert.ToInt32(thread_channel.GatewayPort));
							if (checked_port == false)
							{
								MessageBox.Show("Указанный порт " + thread_channel.GatewayPort + " занят! Попробуйте другой!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
								return;
							}

							port = thread_channel.GatewayPort;
						}

						thread_channel = HARDWARE_GROUP_MODBUS.Channels[i];
						//Получение RxTx 
						ThreadModbusDevicesPoll.EventHandlerEventDevicePollTxRx = new ThreadModbusDevicesPoll.EventDevicePollTxRx(DevicePollTxRxGet);
						//Получение лога
						ThreadModbusDevicesPoll.OnDebug = new ThreadModbusDevicesPoll.DebugData(DevicePollLogGet);
						//Получение информации с TCP сервера
						ThreadModbusDevicesPoll.OnDebugTCPServer = new ThreadModbusDevicesPoll.DebugDataTCPServer(DevicePollTCPServerLogGet);

						ThreadModbusDevicesPoll ModbusDevicesPoll = new ThreadModbusDevicesPoll(thread_channel);

						new Thread(new ParameterizedThreadStart(ModbusDevicesPoll.Work))
						{
							IsBackground = true
						}.Start((object)ModbusDevicesPoll);
					}
				}
			}
		}
		catch 
		{

		}
 }

 private void StopThreads()
 {
		if (HARDWARE_GROUP_MODBUS.Channels != null)
     {
			//Приходимся по списку каналов
			for (int i = 0; i < HARDWARE_GROUP_MODBUS.Channels.Count; i++)
			{
				CHANNEL thread_channel = HARDWARE_GROUP_MODBUS.Channels[i];
				//Останавливаем опрос канал по признаку Потока
				thread_channel.ChannelThreadEnabled = false;
			}
		}
	}

internal class ThreadModbusDevicesPoll
{
    //Канал
    private CHANNEL channel;
    //Асинхронный TCP сервер
    private ListAsyncTCPServer listAsyncTCPServer = new ListAsyncTCPServer();
    AsyncTCPServer atcpserver;
    private int gatewaytypeprotocol = 0;
    private int gatewayport = 60000;
    private int gatewayсonnectedclientsmax = 10;
    private Guid gatewaychannelID;

     public ThreadModbusDevicesPoll(CHANNEL Channel)
     {
         this.channel = Channel;
     }

     public void Work(object obj)
     {

            #region Поток
            //Проверка условия должен ли поток работать (в цикле)
            while (channel.ChannelThreadEnabled == true)
            {
                #region Опрос устройств
        #endregion Опрос устройств
    }
    #endregion Поток
}
    }
}